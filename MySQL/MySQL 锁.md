
** 共享锁和独占锁**
InnoDB实现了标准的行级锁，有两种类型的锁，共享（S）锁和独占（X）锁。
一个共享（S）锁允许持有该锁的事务去读取一条记录。
独占（X）锁允许持有该锁的事务更新或删除某行。
如果事务T1持有r行的共享(S)锁，那么来自不同事务T2对r行的锁的请求被处理如下。
T2对S锁的请求可以被立即批准。结果是，T1和T2都持有r的S锁。
T2对X锁的请求不能被立即批准。
如果一个事务T1在行r上持有一个独占（X）锁，那么某个不同的事务T2对r的任一类型的锁的请求不能立即被批准。相反，事务T2必须等待事务T1释放其对r行的锁。
---- 
**意图锁**
InnoDB支持多粒度锁，允许行锁和表锁共存。例如，一个诸如LOCK TABLES ... WRITE这样的语句在指定的表上使用了一个独占锁（X锁）。为了使多个粒度级别的锁切实可行，InnoDB使用意图锁。意图锁是表级别的锁，它表明事务以后需要对表中的某一行进行哪种类型的锁（共享或独占）。有两种类型的意向锁。
意图共享锁（IS）表示事务打算对表中的个别行设置一个共享锁。
意向排他锁(IX)表示一个事务打算对表中的个别行设置排他锁。
例如，SELECT ... FOR SHARE设置一个IS锁，SELECT ... FOR UPDATE设置一个IX锁。
意图锁协议如下：
在一个事务可以获得表内某行的共享锁之前，它必须首先获得该表的IS锁或更强的锁。
在事务对表中的某一行取得独占锁之前，它必须首先取得该表的IX锁。
表级的锁类型兼容性总结在下面的矩阵中。
![][image-1]
---- 
** 行锁**
行锁是对一个索引记录的锁。例如，`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 防止任何其他事务插入、更新或删除t.c1的值为10的记录。
记录锁总是锁定索引记录，即使一个表被定义为没有索引。对于这种情况，InnoDB创建了一个隐藏的集群索引，并且使用这个索引来锁定记录。参见章节15.6.2.1, "聚类索引和二级索引"。
记录锁的事务数据在SHOW ENGINE INNODB STATUS和InnoDB监控输出中显示类似于以下内容。
```sql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```
---- 
**间隙锁**
间隙锁是对索引记录之间的间隙的锁，或者对第一条或最后一条索引记录之后的间隙的锁。例如，`SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;` 防止其他事务向列t.c1插入一个15的值，无论该列中是否已经有这样的值，因为该范围中所有现有值之间的间隙被锁定。
一个间隙可能横跨一个索引值，多个索引值，甚至是空的。
间隙锁是性能和并发性之间权衡的一部分，在一些事务隔离级别中使用，而不是其他。
对于使用唯一索引锁定行以搜索唯一行的语句，不需要间隙锁。(这不包括搜索条件只包括多列唯一索引中的一些列的情况；在这种情况下，间隙锁定会发生。) 例如，如果id列有一个唯一索引，下面的语句只对id值为100的行使用索引-记录锁，其他会话是否在前面的间隙中插入行并不重要。
```sql
SELECT * FROM child WHERE id = 100;
```
如果id没有索引或者有一个非唯一的索引，该语句会锁定前面的间隙。
这里还值得注意的是，不同的事务可以在一个间隙上持有相互冲突的锁。例如，事务A可以在一个间隙上持有共享间隙锁（间隙S锁），而事务B在同一个间隙上持有排他间隙锁（间隙X锁）。允许冲突的间隙锁的原因是，如果一条记录从索引中被清除，不同的事务对该记录持有的间隙锁必须被合并。

InnoDB中的间隙锁是 "纯抑制性 "的，这意味着它们的唯一目的是防止其他事务插入到间隙中。间隙锁可以同时存在。一个事务取得的间隙锁并不妨碍另一个事务在同一间隙上取得间隙锁。共享间隙锁和独占间隙锁之间没有区别。它们不会相互冲突，而且执行同样的功能。
间隙锁可以被显式地禁用。如果你把事务隔离级别改为READ COMMITTED，就会发生这种情况。在这种情况下，间隙锁在搜索和索引扫描中被禁用，只用于外键约束检查和重复键检查。
使用READ COMMITTED隔离级别还有其他影响。在**MySQL评估了WHERE条件后，非匹配行的记录锁被释放**。对于UPDATE语句，InnoDB做了一个 "半一致 "的读取，比如它返回最新提交的版本给MySQL，这样MySQL可以确定该行是否与UPDATE的WHERE条件相匹配。
---- 
** next-key lock**
next-key lock是索引记录上的记录锁和索引记录前的间隙锁的组合。
InnoDB执行行级锁的方式是，当它搜索或扫描一个表的索引时，它对遇到的索引记录设置共享或独占锁。因此，行级锁实际上是索引-记录锁。一个索引记录上的下一个键锁也会影响到该索引记录之前的 "间隙"。也就是说，下一个键锁是一个索引记录锁加上索引记录之前的空隙锁。如果一个会话对索引中的记录R有一个共享或排他的锁，另一个会话就不能在索引顺序中紧挨着R的空隙中插入一个新的索引记录。
假设一个索引包含10、11、13和20的值。这个索引可能的下一个键锁覆盖了以下的区间，其中圆括号表示排除了区间的端点，方括号表示包含了该端点。
```sql
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```
对于最后一个区间，下一个键锁住了索引中最大的值和 "supremum "伪记录之间的空隙，该伪记录的值高于索引中的任何实际值。supremum不是一个真正的索引记录，所以，实际上，这个下一个键锁只锁定了最大索引值之后的空隙。

默认情况下，InnoDB运行在REPEATABLE READ事务隔离级别。在这种情况下，InnoDB在搜索和索引扫描中使用下一个键锁，这可以防止”Phantom Rows”的出现（参见章节15.7.4，"Phantom Rows"）。
在SHOW ENGINE INNODB STATUS和InnoDB监控输出中，下一个键锁的事务数据类似于以下内容。
---- 
**插入意图锁**
插入意向锁是一种由INSERT操作在行插入前设置的间隙锁。这种锁发出了插入意图的信号，如果多个事务在同一索引间隙中插入的位置不一样，就不需要互相等待。假设有数值为4和7的索引记录。分别试图插入值为5和6的事务，在获得插入行的独占锁之前，各自用插入意图锁锁定了4和7之间的间隙，但是由于这些行是不冲突的，所以不会互相阻塞。
下面的例子演示了一个事务在获得插入记录的独占锁之前，先使用一个插入意向锁。这个例子涉及两个客户，A和B。
客户端A创建了一个包含两个索引记录（90和102）的表，然后启动一个事务，在ID大于100的索引记录上加一个独占锁。该独占锁包括102号记录前的间隙锁。
```sql
mysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
mysql> INSERT INTO child (id) values (90),(102);

mysql> START TRANSACTION;
mysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
```
客户端B开始一个事务，向缺口插入一条记录。该事务在等待获得独占锁的同时，采取了一个插入意向锁。
```sql
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```
在SHOW ENGINE INNODB STATUS和InnoDB监控输出中，插入意向锁的事务数据显示类似于以下内容。
```sql
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
```
---- 
**AUTO-INC锁**
AUTO-INC锁是一个特殊的表级锁，由事务插入到具有AUTO\_INCREMENT列的表中。在最简单的情况下，如果一个事务正在向表中插入数值，任何其他事务必须等待向该表进行自己的插入，这样第一个事务插入的行就会得到连续的主键值。

`innodb_autoinc_lock_mode`变量控制用于自动增量锁定的算法。它允许你选择如何在可预测的自动递增值序列和插入操作的最大并发性之间进行权衡。

[image-1]:	https://tva1.sinaimg.cn/large/008i3skNly1grhwmb3lypj30oa09gmxy.jpg