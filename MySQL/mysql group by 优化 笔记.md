mysql group by 优化 笔记
常规执行过程：
step1: 全表扫描；step2: 创建临时表；step3: 发现group；step4: 应用聚合函数
可以优化的部分：是否可以不走全表扫描？
   是否可以不用创建临时表？

loose index scan：
需要满足以下条件：
-1.  查询语句是单表查询
-2. group by 字段列表满足索引的极左匹配原则
-3. 聚合函数只能是min() 或 max()，并且是针对同一字段做聚合
-4. 索引中的字段中没有在group by 中出现的，但是却在query中出现了，必须是“=” 常量的形式出现。
-5. 索引的字段必须是对整个列做索引，不能是列的一部分
还有一种情况：
在满足1，2，4，5的条件下，
- 聚合函数还可以是AVG(distinct x)或者 SUM(distinct x)或者COUNT(distinct x1, x2)
- 在查询中没有出现其它的distinct 或 group by语句。

tight index scan：
需要满足的条件：
当不满足松散索引扫描的条件时，仍然可能避免为GROUP BY查询创建临时表。如果WHERE子句中有范围条件，则该方法只读取满足这些条件的键。否则，它将执行索引扫描。因为这个方法会读取WHERE子句定义的每个范围内的所有键，如果没有范围条件，则扫描整个索引，所以称为紧索引扫描。在紧缩索引扫描中，只有在找到所有满足范围条件的键之后，才会执行分组操作。

为了使这种方法有效，只需要在查询中的所有列都有一个**常量的平等条件**，**这个条件是指在GROUP BY键的前面或中间的部分的键**。来自平等条件的常量填补了搜索键中的任何 "空白"，这样就可以形成完整的索引前缀。这些索引前缀就可以用于索引查找。如果GROUP BY结果需要排序，并且可以形成索引前缀的搜索键，那么MySQL还可以避免额外的排序操作，因为在有序索引中使用前缀进行搜索已经可以按顺序检索到所有的键。
