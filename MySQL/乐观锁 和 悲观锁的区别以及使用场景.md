## 悲观锁
假设每次操作都有可能数据被别人修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
适用于“写多读少”的场景。

## 乐观锁
只在更新的时候判断数据有没有被修改过，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于`write_condition`机制，其实都是提供的乐观锁。
适用于“写少读多”的场景。
如果是“写多读少”的场景，乐观锁会频繁的retry，效率会非常低，直接使用悲观锁就可以。
### 乐观锁的实现方式
#### 版本号机制（版本向量机制）
每条记录添加一个version字段，每次更新记录都要更新version的值
在更新数据时，检查当前数据和version是否一致，如果一致就更新，不一致就放弃。
#### CAS
存在的问题：ABA问题
A 是原值的意思，更新的时候检查当前值是否是还是A值，但是A值有可能不是之前的那个A值了。
