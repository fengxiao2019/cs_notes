当新的configEpoch值在故障切换期间通过从属推广创建时，它们被保证是唯一的。

然而，有两个不同的事件，新的configEpoch值是以不安全的方式创建的，只是增加了本地节点的currentEpoch，同时希望没有冲突。这两个事件都是由系统管理员触发的。

带有`TAKEOVER`选项的`CLUSTER FAILOVER`命令能够在大多数主站无法使用的情况下手动将一个从站节点提升为主站。例如，这在多数据中心设置中是很有用的。
出于性能方面的考虑，集群再平衡的插槽迁移也会在本地节点内产生新的配置纪元，而不需要达成协议。
具体来说，在手动重构过程中，当一个哈希槽从节点A迁移到节点B时，重构程序将强制B将其配置升级到集群中发现的最大纪元，再加1（除非该节点已经是拥有最大配置纪元的节点），而不需要其他节点同意。通常情况下，现实世界的重新分区涉及到移动几百个哈希槽（特别是在小集群中）。在重新分片期间，每移动一个哈希槽，都要求同意生成新的配置历时，这样做效率很低。此外，每次都需要在集群的每个节点上进行fsync，以存储新的配置。由于采用了这种方式，我们只需要在移动第一个哈希槽时进行新的配置历时，这使得它在生产环境中更加高效。

然而，由于上述两种情况，有可能（尽管不太可能）出现多个节点拥有相同配置历时的情况。由系统管理员执行的重新分区操作，以及同时发生的故障切换（加上很多坏运气），如果传播速度不够快，可能会导致currentEpoch碰撞。

此外，软件错误和文件系统损坏也会导致多个节点拥有相同的配置纪元。

当服务于不同哈希槽的主站拥有相同的configEpoch时，就没有问题了。更重要的是，在主站之上失效的从站具有独特的配置纪元。

也就是说，人工干预或重新分片可能会以不同的方式改变集群的配置。Redis集群的主要有效性属性要求槽的配置总是收敛的，所以在任何情况下，我们真的希望所有主节点都有不同的configEpoch。

为了执行这一点，在两个节点最终拥有相同的configEpoch的情况下，会使用一种冲突解决算法。

如果一个主节点检测到另一个主节点正在用相同的configEpoch宣传自己。
并且如果该节点的节点ID在词典上比另一个声称拥有相同configEpoch的节点要小。
那么，它将其当前的Epoch增加1，并将其作为新的configEpoch。
如果有任何一组节点具有相同的configEpoch，除了具有最大节点ID的节点外，所有的节点都会向前移动，保证最终每个节点都会选择一个唯一的configEpoch，不管发生了什么。

这个机制也保证了在一个新的集群被创建后，所有的节点都以不同的 configEpoch 开始（即使这实际上没有被使用），因为 redis-trib 确保在启动时使用 CONFIG SET-CONFIG-EPOCH。然而，如果由于某种原因，一个节点被错误配置，它将自动更新其配置到不同的配置纪元。