Python event loop

头大的厉害
调度器维护的第二个Future集合包括那些仍在等待某种I/O的Future。这些Future以某种方式被映射到一个select/poll/etc.包装器上，当一个特定的文件描述符准备好进行I/O时，它就会调用一个回调。回调实际上执行了future所要求的I/O操作，将future的结果值设置为I/O操作的结果，并将future移到可运行队列中。当然，确切的细节要复杂得多，但它们对这个解释并不重要。


现在我们开始讨论有趣的部分了。假设你正在写一些复杂的协议实现。在协议的深处，你正在使用recv()方法从一个套接字中读取字节。这些字节会进入一个缓冲区。recv()方法被包裹在一个异步包装器中，该包装器设置了I/O，并返回一个将在I/O完成时完成的未来，正如我上面解释的那样。现在，假设你的代码中有一些其他部分想从缓冲区中一行一行地读取数据。让我们假设你通过创建一个readline()方法来抽象出这一点。假设缓冲区的大小比平均行长要大一些，通常情况下，你的readline()方法可以直接从缓冲区获得下一行，而不需要阻塞；但有时缓冲区没有整行，现在readline()必须反过来调用socket上的recv()。

问题：readline()是否应该返回一个Future？如果它有时返回一个字节字符串，有时返回一个future，迫使调用者做一个类型检查和一个条件输出，那就不太妙了。所以答案是，readline()必须总是返回一个future。当 readline() 被调用时，它在缓冲区中寻找，如果它发现那里至少有一整行，它就创建一个 future，将 future 的结果设置为从缓冲区中取出的行，并返回该 future。如果缓冲区中没有整行，它就启动I/O并等待它，当I/O完成后，它就从头开始。细节留给读者做个练习。在实践中，通常还有另一个层次，即read()本身推迟到一个较低层次的recv()调用，该调用实际上执行套接字I/O。


